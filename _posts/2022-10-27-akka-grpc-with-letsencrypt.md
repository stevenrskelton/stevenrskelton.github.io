---
title: "Akka gRPC with Let's Encrypt"
categories:
  - Platform
  - Scala
tags:
  - TradeAudit
published: false
---
The Electric Frontier Foundation (EFF) has recommendations about [encrypting the web](https://www.eff.org/encrypt-the-web); there is no reason to be 
running servers over unencrypted HTTP any longer. It is irresponsible to your users and unnecessary. [Let's Encrypt](https://letsencrypt.org/) is 
the most popular way to get a free TLS certificate so cost is no longer a factor.  
_(Many still refer to these incorrectly as the outdated an SSL certificate, leaving libraries such as OpenSSL unfortunately named but HTTPS uses TLS now)_

While there is no longer a cost associated to HTTPS, there are configuration difficulties. Even glossing over certificate revocation, certificate expiration is a plague in most enterprises.  In my experience TLS certificates has been mostly a manual process, especially with self-signed certs being used in non-production environments. Especially in a microservice setup, development teams would constantly be running into expired certificates that were manually created year(s) ago.

The The Let's Encrypt Certbot tool automates renewal, and it is arguably better to use Let's Encrypt's practice of 90 expiry even when you have the choice for more.  DevOps tools rust without use and 90 day processes essentially force automation.


## Akka HTTP / gRPC

According to the Akka documentation: Akka relies on the JVM TLS implementation, which is sufficient for many use cases, but is planned to be replaced with conscrypt or netty-tcnative.  I think this means instead of using the public/private PEM key pair generated by Certbot directly, like you can with other software such as Nginx, its easiest to use a single PKCS12 file.  This is an extra step (and another password to manage), but hardly extra work in an automated flow.

While working through commands to generate the PKCS12 file, there is a minor issue as noted at [https://community.letsencrypt.org/t/cannot-verify-domain-with-openssl/11545](https://community.letsencrypt.org/t/cannot-verify-domain-with-openssl/11545), that the chain seems incomplete, so it is necessary to pass the `fullchain.pem` to `-in` below instead of the expected `cert.pem` below:

```
openssl pkcs12 -export \
	 -in /etc/letsencrypt/live/[your-url]/fullchain.pem \
	 -inkey /etc/letsencrypt/live/[your-url]/privkey.pem \
	 -out /etc/letsencrypt/live/[your-url]/cert.pkcs12 \
	 -name [your-url] \
	 -CAfile /etc/letsencrypt/live/[your-url]/fullchain.pem \
	 -caname "Let's Encrypt Authority X3" \
	 -password pass:[your-password]
```

This `cert.pkcs12` is the only file necessary now to enable HTTPS server-side encryption, so it can be copied to where it can be securely accessed by the Akka application.

Enabling HTTPS on a gRPC or HTTP server in Akka is done by calling `enableHttps` in the builder with a `httpsConnectionContext`.

```scala
Http(actorSystem)
  .newServerAt(interface, port)
  .enableHttps(httpsConnectionContext)
  .bind(routes)
```

The `httpsConnectionContext` is generated using a JVM Keystore, which is a sensitive file containing private keys to TLS certificates, and shouldn't be confused with a Truststore such as `cacerts` that contains only _public_ keys.

To create an `HttpsConnectionContext`, we generate a new Keystore, load the `cert.pkcs12` into it, and then load this into a new `SSLContext`:

```scala
def serverHttpsContext(pkcs12File: File, pkcs12Password: String): Try[HttpsConnectionContext] = {
  Using(new FileInputStream(pkcs12File)) {
    contentStream =>
      val ks = KeyStore.getInstance("PKCS12")
      ks.load(contentStream, pkcs12Password.toCharArray)
      ks
  }.map {
    keyStore =>
      val keyManagerFactory = KeyManagerFactory.getInstance("SunX509")
      keyManagerFactory.init(keyStore, pkcs12Password.toCharArray)
      val context = SSLContext.getInstance("TLS")
      context.init(keyManagerFactory.getKeyManagers, null, new SecureRandom)
      ConnectionContext.httpsServer(context)
  }
}
```


